<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p><b>AI INTERNAL LAB <br/> <br/></b></p>
<p><b>1. TIC-TAC-TOE <br/> <br/>Program: <br/> <br/></b>import random <br/>def print_board(board): <br/>    for row in board: <br/>        print(&quot; | &quot;.join(row)) <br/>    print()  <br/>def check_winner(board, player): <br/>    win_cond = [ <br/>        [board[0][0], board[0][1], board[0][2]], <br/>        [board[1][0], board[1][1], board[1][2]], <br/>        [board[2][0], board[2][1], board[2][2]], <br/>        [board[0][0], board[1][0], board[2][0]], <br/>        [board[0][1], board[1][1], board[2][1]], <br/>        [board[0][2], board[1][2], board[2][2]], <br/>        [board[0][0], board[1][1], board[2][2]], <br/>        [board[2][0], board[1][1], board[0][2]], <br/>    ] <br/>    return [player, player, player] in win_cond <br/>def get_computer_move(board): <br/>    empty_cells = [(r, c) for r in range(3) for c in range(3) if board[r][c] == &quot; &quot;] <br/>    return random.choice(empty_cells) <br/>def tic_tac_toe(): <br/>    board = [[&quot; &quot; for _ in range(3)] for _ in range(3)] <br/>    players = [&quot;x&quot;, &quot;O&quot;] <br/>    turn = 0 <br/>    for _ in range(9): <br/>        print_board(board) <br/>        if turn % 2 == 0: <br/>            row, col = map(int, input(&quot;Player x, enter row and column (0,1,2): &quot;).split()) <br/>        else: <br/>            row, col = get_computer_move(board) <br/>            print(f&quot;Computer O chooses row {row} and column {col}&quot;) <br/>        if board[row][col] == &quot; &quot;: <br/>            board[row][col] = players[turn % 2] <br/>            if check_winner(board, players[turn % 2]): <br/>                print_board(board) <br/>                print(f&quot;Player {players[turn % 2]} wins!&quot;) <br/>                return <br/>            turn += 1 <br/>        else: <br/>            print(&quot;Cell already taken, try again.&quot;) <br/>    print_board(board) </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>    print(&quot;It's a draw!&quot;) <br/>if __name__ == &quot;__main__&quot;: <br/>    tic_tac_toe() <br/> <br/><b>OUTPUT <br/></b> <br/>|   |   <br/>  |   |   <br/>  |   |   <br/> <br/>Player x, enter row and column (0,1,2): 1 1 <br/>  |   |   <br/>  | x |   <br/>  |   |   <br/> <br/>Computer O chooses row 2 and column 2 <br/>  |   |   <br/>  | x |   <br/>  |   | O <br/> <br/>Player x, enter row and column (0,1,2): 2 0 <br/>  |   |   <br/>  | x |   <br/>x |   | O <br/> <br/>Computer O chooses row 2 and column 1 <br/>  |   |   <br/>  | x |   <br/>x | O | O <br/> <br/>Player x, enter row and column (0,1,2): 0 2 <br/>  |   | x <br/>  | x |   <br/>x | O | O <br/> <br/>Player x wins! <br/><b> <br/> <br/> <br/> <br/> <br/>2.WATER-JUG PROBLEM <br/>Program: <br/></b>x=5 <br/>y=3 <br/>x1=int(input(&quot;Enter the initial amount of water in 5 liter jug : &quot;)) <br/>y1=int(input(&quot;Enter the initial amount of water in 3 liter jug : &quot;)) </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>s=4 <br/>while True: <br/>    rule=int(input(&quot;Enter the rule no : &quot;)) <br/>    if(rule==1): <br/>        if x1&lt;x:x1=x <br/>    if rule==2: <br/>        if x1&gt;0:x1=0 <br/>    if rule==3: <br/>        if y1&lt;y:y1=y <br/>    if rule==4: <br/>        if y1&gt;0:y1=0 <br/>    if rule==5: <br/>        if x1+y1&lt;=3 and y1&gt;0:x1,y1=x1+y1,0 <br/>    if rule==6: <br/>        if x1+y1&lt;=5 and x1&gt;0:x1,y1=0,x1+y1 <br/>    if rule==7: <br/>        if x1+y1&gt;=3:x1,y1=5,x1+y1-5 <br/>    if rule==8: <br/>        if x1+y1&gt;=5:x1,y1=x1+y1-3,3 <br/>    print(f&quot;X is : {x1}\n Y is : {y1}&quot;) <br/>    if x1==s: <br/>        print(&quot;The goal state is reached&quot;) <br/>        break <br/><b>OUTPUT <br/></b>Enter the initial amount of water in 5 liter jug : 0<b> <br/></b>Enter the initial amount of water in 3 liter jug : 0 <br/>Enter the rule no : 1 <br/>X is : 5 <br/> Y is : 0 <br/>Enter the rule no : 8 <br/>X is : 2 <br/> Y is : 3 <br/>Enter the rule no : 4 <br/>X is : 2 <br/> Y is : 0 <br/>Enter the rule no : 6 <br/>X is : 0 <br/> Y is : 2 <br/>Enter the rule no : 1 <br/>X is : 5 <br/> Y is : 2 <br/>Enter the rule no : 8 <br/>X is : 4 <br/> Y is : 3 <br/>The goal state is reached <br/> <br/> </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>         <br/><b>3.BFS <br/>Program <br/></b>'''graph = { <br/> '5' : ['3','7'], <br/>  '3' : ['2', '4'], <br/>  '7' : ['8'], <br/>  '2' : [], <br/>  '4' : ['8'], <br/>  '8' : [] <br/>}''' <br/>graph = { <br/>    'P' : ['Q','R','S'], <br/>    'Q' : [], <br/>    'R' : ['Q','T'], <br/>    'S' : [], <br/>    'T' : [] <br/>    } <br/>visited = []  <br/>queue = []     <br/>def bfs(visited, graph, node):  <br/>  visited.append(node) <br/>  queue.append(node) <br/>  while queue:         <br/>    m = queue.pop(0)  <br/>    print (m, end = &quot; &quot;)  <br/>    for neighbour in graph[m]: <br/>      if neighbour not in visited: <br/>        visited.append(neighbour) <br/>        queue.append(neighbour) <br/>print(&quot;Following is the Breadth-First Search&quot;) <br/>bfs(visited, graph, 'P') <br/><b>OUTPUT <br/></b></p>
<p><b> <br/>Following is the Breadth-First Search <br/></b></p>
<p><b>P Q R S T <br/></b> <br/><b> <br/></b></p>
<p><b> <br/> <br/>4.DFS <br/></b></p>
<p><b>Program :  <br/></b>graph = { <br/></p>
<p>  '5' : ['3','7'], <br/>  '3' : ['2', '4'], <br/>  '7' : ['8'], <br/>  '2' : [], </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>  '4' : ['8'], <br/>  '8' : [] <br/>} <br/>visited = set()  <br/>def dfs(visited, graph, node): <br/>    if node not in visited: <br/>        print (node , end=&quot; &quot;) <br/>        visited.add(node) <br/>        for neighbour in graph[node]: <br/>            dfs(visited, graph, neighbour) <br/>print(&quot;Following is the Depth-First Search&quot;) <br/>dfs(visited, graph, '5') <br/><b>OUTPUT :  <br/>Following is the Depth-First Search <br/>5 3 2 4 8 7 <br/> <br/></b>5.  <b>8-PUZZLE-PROBLEM <br/> <br/>Program :  <br/> <br/></b>def puzzle(): <br/>    row = [] <br/>    for i in range(3): <br/>        col = [] <br/>        for j in range(3): <br/>            val = int(input(&quot;Enter the values for row {}, column {}: &quot;.format(i+1, j+1))) <br/>            col.append(val) <br/>        row.append(col) <br/>    return row <br/>def checkGoal(initial_state, final_state): <br/>    return initial_state == final_state <br/>def findBlank(initial_state): <br/>    for i in range(3): <br/>        for j in range(3): <br/>            if initial_state[i][j] == 0: <br/>                return i, j <br/>def checkMoves(i, j): <br/>    moves = [] <br/>    if i &gt; 0: <br/>        moves.append((i - 1, j)) <br/>    if i &lt; 2:  # Since it's a 3x3 board, index 2 is the last row <br/>        moves.append((i + 1, j)) <br/>    if j &gt; 0: <br/>        moves.append((i, j - 1)) <br/>    # Right <br/>    if j &lt; 2:   <br/>        moves.append((i, j + 1)) </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>    return moves <br/>def makeMove(initial_state, blank_pos, move): <br/>    new_state = [row[:] for row in initial_state]   <br/>    i, j = blank_pos <br/>    new_i, new_j = move <br/>    new_state[i][j], new_state[new_i][new_j] = new_state[new_i][new_j], <br/>new_state[i][j] <br/>    return new_state <br/>from collections import deque <br/>def solvePuzzle(initial_state, final_state): <br/>    queue = deque([(initial_state, findBlank(initial_state), [])]) <br/>    visited = set()   <br/>    while queue: <br/>        current_state, blank_pos, path = queue.popleft() <br/>        if checkGoal(current_state, final_state): <br/>            return path <br/>        visited.add(tuple(tuple(row) for row in current_state)) <br/>        for move in checkMoves(*blank_pos): <br/>            new_state = makeMove(current_state, blank_pos, move) <br/>            if tuple(tuple(row) for row in new_state) not in visited: <br/>                queue.append((new_state, move, path + [move])) <br/>    return None  <br/>final_state = [[1, 2, 3], [4, 0, 5], [6, 7, 8]] <br/>initial_state = puzzle() <br/>solution = solvePuzzle(initial_state, final_state) <br/>if solution: <br/>    print(&quot;Solution found:&quot;, solution) <br/>else: <br/>    print(&quot;No solution found.&quot;) <br/> <br/><b>OUTPUT :  <br/></b>Enter the values for row 1, column 1: 1 <br/>Enter the values for row 1, column 2: 2 <br/>Enter the values for row 1, column 3: 3 <br/>Enter the values for row 2, column 1: 4 <br/>Enter the values for row 2, column 2: 5 <br/>Enter the values for row 2, column 3: 6 <br/>Enter the values for row 3, column 1: 7 <br/>Enter the values for row 3, column 2: 8 <br/>Enter the values for row 3, column 3: 0 <br/>Solution found: [(2, 1), (2, 0), (1, 0), (1, 1), (1, 2), (2, 2), (2, 1), (1, 1), (1, 0), (2, 0), (2, 1), <br/>(2, 2), (1, 2), (1, 1)] <br/> <br/> <br/> <br/>6.<b>TOWERS OF HANOI <br/> </b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Program  :  <br/></b>n=3 <br/>def hanoi(n,from1,to,aux): <br/>    if n==0: <br/>        return -1 <br/>    hanoi(n-1,from1,aux,to) <br/>    print(&quot;Move to disk&quot;,n,&quot;from rod&quot;,from1,&quot;to rod&quot;,to,&quot;using Auxiliary rod&quot;,aux) <br/>    hanoi(n-1,aux,to,from1) <br/>hanoi(n,'A','B','C') <br/> <br/><b>OUTPUT :  <br/></b> <br/>Move to disk 1 from rod A to rod B using Auxiliary rod C <br/>Move to disk 2 from rod A to rod C using Auxiliary rod B <br/>Move to disk 1 from rod B to rod C using Auxiliary rod A <br/>Move to disk 3 from rod A to rod B using Auxiliary rod C <br/>Move to disk 1 from rod C to rod A using Auxiliary rod B <br/>Move to disk 2 from rod C to rod B using Auxiliary rod A <br/>Move to disk 1 from rod A to rod B using Auxiliary rod C <br/> <br/> <br/> <br/><b>7</b>. <b>MISSIONARIES AND CANNIBALS <br/> <br/>Program  :  <br/> <br/></b>nlm = 3   <br/>nlc = 3   <br/>nrm = 0   <br/>nrc = 0   <br/>direction = &quot;left&quot; <br/>print(&quot;Left to Right : &quot;) <br/>print(nlm, &quot;M&quot;, &quot;|&quot;, nlc, &quot;C&quot;, &quot;----&gt;&quot;, nrm, &quot;M&quot;, &quot;|&quot;, nrc, &quot;C&quot;) <br/>k=0 <br/>def checkSafe(lm, rm, lc, rc): <br/>    if lm &lt; 0 or lc &lt; 0 or rm &lt; 0 or rc &lt; 0: <br/>        return False <br/>    if (lm &gt; 0 and lc &gt; lm) or (rm &gt; 0 and rc &gt; rm): <br/>        return False <br/>    return True <br/>while True: <br/>    if direction == &quot;left&quot;: <br/>        um = int(input(&quot;Enter no of missionaries to travel from left to right: &quot;)) <br/>        uc = int(input(&quot;Enter no of cannibals to travel from left to right: &quot;)) <br/>        if um + uc &gt; 2 or um + uc == 0 or um &lt; 0 or uc &lt; 0: <br/>            print(&quot;Invalid input&quot;) <br/>            continue </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>        new_nlm = nlm - um <br/>        new_nlc = nlc - uc <br/>        new_nrm = nrm + um <br/>        new_nrc = nrc + uc <br/>        if not checkSafe(new_nlm, new_nrm, new_nlc, new_nrc): <br/>            print(&quot;Move is not safe, try again.&quot;) <br/>            continue <br/>        nlm, nlc, nrm, nrc = new_nlm, new_nlc, new_nrm, new_nrc <br/>        k+=1 <br/>        print(&quot;Left Side to Right Side:&quot;) <br/>        print(nlm, &quot;M&quot;, &quot;|&quot;, nlc, &quot;C&quot;, &quot;----&gt;&quot;, nrm, &quot;M&quot;, &quot;|&quot;, nrc, &quot;C&quot;) <br/>        direction = &quot;right&quot; <br/>    else: <br/>        um = int(input(&quot;Enter no of missionaries to travel from right to left: &quot;)) <br/>        uc = int(input(&quot;Enter no of cannibals to travel from right to left: &quot;)) <br/>        if um + uc &gt; 2 or um + uc == 0 or um &lt; 0 or uc &lt; 0: <br/>            print(&quot;Invalid input&quot;) <br/>            continue <br/>        new_nlm = nlm + um <br/>        new_nlc = nlc + uc <br/>        new_nrm = nrm - um <br/>        new_nrc = nrc - uc <br/>        if not checkSafe(new_nlm, new_nrm, new_nlc, new_nrc): <br/>            print(&quot;Move is not safe, try again.&quot;) <br/>            continue  <br/>        nlm, nlc, nrm, nrc = new_nlm, new_nlc, new_nrm, new_nrc <br/>        k+=1 <br/>        print(&quot;Right Side to Left Side:&quot;) <br/>        print(nlm, &quot;M&quot;, &quot;|&quot;, nlc, &quot;C&quot;, &quot;----&gt;&quot;, nrm, &quot;M&quot;, &quot;|&quot;, nrc, &quot;C&quot;) <br/>        direction = &quot;left&quot; <br/>    if nrm == 3 and nrc == 3: <br/>        print(&quot;Goal State is reached&quot;) <br/>        print(nlm, &quot;M&quot;, &quot;|&quot;, nlc, &quot;C&quot;, &quot;----&gt;&quot;, nrm, &quot;M&quot;, &quot;|&quot;, nrc, &quot;C&quot;) <br/>        print(&quot;No of Steps : &quot;,k) <br/>        break <br/> <br/><b> <br/> <br/>OUTPUT :  <br/></b>Left to Right :  <br/>3 M | 3 C ----&gt; 0 M | 0 C <br/>Enter no of missionaries to travel from left to right: 1 <br/>Enter no of cannibals to travel from left to right: 1 <br/>Left Side to Right Side: <br/>2 M | 2 C ----&gt; 1 M | 1 C <br/>Enter no of missionaries to travel from right to left: 1 <br/>Enter no of cannibals to travel from right to left: 0 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Right Side to Left Side: <br/>3 M | 2 C ----&gt; 0 M | 1 C <br/>Enter no of missionaries to travel from left to right: 0 <br/>Enter no of cannibals to travel from left to right: 2 <br/>Left Side to Right Side: <br/>3 M | 0 C ----&gt; 0 M | 3 C <br/>Enter no of missionaries to travel from right to left: 0 <br/>Enter no of cannibals to travel from right to left: 1 <br/>Right Side to Left Side: <br/>3 M | 1 C ----&gt; 0 M | 2 C <br/>Enter no of missionaries to travel from left to right: 2 <br/>Enter no of cannibals to travel from left to right: 0 <br/>Left Side to Right Side: <br/>1 M | 1 C ----&gt; 2 M | 2 C <br/>Enter no of missionaries to travel from right to left: 1 <br/>Enter no of cannibals to travel from right to left: 1 <br/>Right Side to Left Side: <br/>2 M | 2 C ----&gt; 1 M | 1 C <br/>Enter no of missionaries to travel from left to right: 2 <br/>Enter no of cannibals to travel from left to right: 0 <br/>Left Side to Right Side: <br/>0 M | 2 C ----&gt; 3 M | 1 C <br/>Enter no of missionaries to travel from right to left: 0 <br/>Enter no of cannibals to travel from right to left: 1 <br/>Right Side to Left Side: <br/>0 M | 3 C ----&gt; 3 M | 0 C <br/>Enter no of missionaries to travel from left to right: 0 <br/>Enter no of cannibals to travel from left to right: 2 <br/>Left Side to Right Side: <br/>0 M | 1 C ----&gt; 3 M | 2 C <br/>Enter no of missionaries to travel from right to left: 0 <br/>Enter no of cannibals to travel from right to left: 1 <br/>Right Side to Left Side: <br/>0 M | 2 C ----&gt; 3 M | 1 C <br/>Enter no of missionaries to travel from left to right: 0 <br/>Enter no of cannibals to travel from left to right: 2 <br/>Left Side to Right Side: <br/>0 M | 0 C ----&gt; 3 M | 3 C <br/>Goal State is reached <br/>0 M | 0 C ----&gt; 3 M | 3 C <br/>No of Steps :  11 <br/> <br/> <br/> <br/>8.<b>TRAVELLING SALESMAN PROBLEM  <br/> <br/>Program :  </b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b> <br/></b>from itertools import permutations <br/>def calculateDistance(graph, route): <br/>    total_distance = 0 <br/>    num_cities = len(route) <br/>    for i in range(num_cities - 1): <br/>        total_distance += graph[route[i]][route[i + 1]] <br/>    total_distance += graph[route[-1]][route[0]] <br/>    return total_distance <br/>def travelingSalesman(graph): <br/>    num_cities = len(graph) <br/>    cities = [i for i in range(num_cities)] <br/>    all_routes = permutations(cities) <br/>    min_cost = float('inf') <br/>    best_route = None <br/>    for route in all_routes: <br/>        current_cost = calculateDistance(graph, route) <br/>        if current_cost &lt; min_cost: <br/>            min_cost = current_cost <br/>            best_route = route <br/>    return min_cost, best_route <br/>graph = [ <br/>    [0, 10, 15, 20], <br/>    [10, 0, 35, 25], <br/>    [15, 35, 0, 30], <br/>    [20, 25, 30, 0] <br/>] <br/>min_cost, best_route = travelingSalesman(graph) <br/>print(&quot;Minimum cost:&quot;, min_cost) <br/>print(&quot;Best route:&quot;, best_route) <br/> <br/><b>OUTPUT <br/></b>Minimum cost: 80 <br/>Best route: (0, 1, 3, 2) #A-0,B-1,C-2,D-3 <br/> <br/><b>Program -9  <br/>Monkey banana  <br/></b>def solve(banana, box, height, monkey, hold): <br/>    if monkey == banana and height == 1: <br/>        ans.append(&quot;Monkey took banana&quot;) <br/>        return True <br/>    if (banana, box, height, monkey, hold) in d: <br/>        return False <br/>    d[(banana, box, height, monkey, hold)] = 1 <br/>    found = 0 <br/>    options = { <br/>        1: &quot;Move to box&quot;, </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>        2: &quot;Move to banana&quot;, <br/>        3: &quot;Climb onto the box&quot;, <br/>        4: &quot;Hold box to move&quot; <br/>    } <br/>    for option in options: <br/>        if option == 1 and hold == 0 and height == 0 and solve(banana, box, height, box, <br/>hold): <br/>            ans.append(options[option]) <br/>            found = 1 <br/>            break <br/>        elif option == 2 and height == 0 and ((hold == 1 and solve(banana, banana, <br/>height, banana, hold)) or (hold == 0 and solve(banana, box, height, banana, hold))): <br/>            ans.append(options[option]) <br/>            found = 1 <br/>            break <br/>        elif option == 3 and height == 0 and monkey == box and solve(banana, box, <br/>height + 1, monkey, 0): <br/>            ans.append(options[option]) <br/>            found = 1 <br/>            break <br/>        elif option == 4 and height == 0 and monkey == box and solve(banana, box, <br/>height, monkey, 1): <br/>            ans.append(options[option]) <br/>            found = 1 <br/>            break <br/>    return found <br/>n = int(input(&quot;Enter the size of the world: &quot;)) <br/>world = [[0] * n for _ in range(n)] <br/>x, y = map(int, input(&quot;Enter tree position: &quot;).split()) <br/>world[x][y] = -1   <br/>banana = (x, y) <br/>x, y = map(int, input(&quot;Enter monkey position: &quot;).split()) <br/>monkey_start = (x, y) <br/>for i in range(n): <br/>    for j in range(n): <br/>        if world[i][j] == -1: <br/>            print(f&quot;Banana tree found at ({i}, {j})&quot;) <br/>            box = (i, j) <br/>d = {} <br/>ans = [] <br/>solve(banana, box, 0, monkey_start, 0) <br/>ans.reverse() <br/>print(*ans, sep=&quot;\n&quot;) <br/> <br/><b>output: <br/></b>Enter the size of the world: 6 <br/>Enter tree position: 2 2 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Enter monkey position: 4 4 <br/>Banana tree found at (2, 2) <br/>Move to box <br/>Climb onto the box <br/>Monkey took banana <br/> <br/><b>Program -10 <br/>N queens <br/></b>def print_solution(board): <br/>    for row in board: <br/>        print(&quot; &quot;.join(str(x) for x in row)) <br/>    print() <br/>def is_safe(board, row, col, N): <br/>    for i in range(col): <br/>        if board[row][i] == 1: <br/>            return False <br/>    for i, j in zip(range(row, -1, -1), range(col, -1, -1)): <br/>        if board[i][j] == 1: <br/>            return False <br/>    for i, j in zip(range(row, N), range(col, -1, -1)): <br/>        if i &lt; N and board[i][j] == 1: <br/>            return False <br/>    return True <br/>def solve_nq_util(board, col, N): <br/>    if col &gt;= N: <br/>        return True <br/>    for i in range(N): <br/>        if is_safe(board, i, col, N): <br/>            board[i][col] = 1   <br/>            if solve_nq_util(board, col + 1, N):   <br/>                return True <br/>            board[i][col] = 0   <br/>    return False <br/>def solve_nq(N): <br/>    board = [[0 for _ in range(N)] for _ in range(N)] <br/>    if not solve_nq_util(board, 0, N): <br/>        print(&quot;Solution doesn't exist&quot;) <br/>        return False <br/>    print_solution(board) <br/>    return True <br/>N = int(input(&quot;Enter the size of the board (N): &quot;)) <br/>solve_nq(N) <br/> <br/>Output: <br/>Enter the size of the board (N): 5 <br/>1 0 0 0 0 <br/>0 0 0 1 0 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>0 1 0 0 0 <br/>0 0 0 0 1 <br/>0 0 1 0 0 <br/> <br/> </p>

</div></div>
</body></html>